

## Raft

- 根据论文In Search of an Understandable Consensus Algorithm了解Raft，为了写6.5480的Raft lab详细读论文。

### 摘要

Raft可以生成一个和Paxos相同的结果而且比Paxos更好理解。Raft更适合做现实中要落地的系统，为了增加可理解性，Raft把共识机制拆成了好几点，有leader election， log replication 和 safety，它还减少了要考虑的状态。

### Raft 算法

先选一个leader，然后让leader处理replicated log， leader要接受用户的log entry然后把他们replicate给其他的服务器，还要告诉服务器什么时候把log entries应用到state machines上面去。这样做的好处是replicated log 的处理更加简单了，leader可以决定把entry放在log的什么位置，然后log只会从leader走向其他服务器，当一个leader失效的时候新的leader会被选举出来。Raft把共识分解成了三个部分，leader election， log replication，和 safety。

#### 基础

- 服务器有三种状态，leader， follower和candidate。通常情况下有一个leader然后其他服务器都是follower。follower自己不会发请求只回应leader和candicate的请求。leader处理所有用户的请求，如果用户联系了follower，follower会把请求重定向给leader，candidate用来选举一个新的leader。
- Raft把时间分成任意长度的term，每个term都以一个选举开始，一个或者多个candidate希望成为leader。如果一个candidate在选举中获胜，那么在这个term他就是leader。在某些情况下会出现平票。这样的话这个term就会没有leader，一个新的term会马上开始。Raft保证了在一个term里只会有最多一个leader。
- 不同的server在不同的时间观察到term的变化，在某些情况下一些server可能不会观察到election或者一整个term。term像一个逻辑时间一样，让服务器发掘一些过时的信息，比如过时的leader。每个server存一个current term。在服务器之间通信的时候current term交换了，如果一个服务器的current 比别人小，他会更新到更大的值。如果一个leader或者candidate发现他的term过时了，就会立刻变成follower。如果server收到了一个过时的term，就会拒绝相应的请求。
- server之间用RPC通信，基础的共识只用两种RPC，requestVote和AppendEntries。requestVote是candidate用来拉票的，AppendEntries是leader用来replicate log entries和提供heartbeat的。heartbeat是一种特殊的Appendentries

#### Leader election

- Raft用一种心跳机制来开启leader election。当服务器启动的时候都是follower，只要服务器从leader或者candidate收到有效的RPC他就会保持follower的状态。leader会向follower定期发送heartbeat来保持authority。当一个follower在一段时间内没有收到通信（这段时间被叫做 election time out），他就会认为没有合法的leader，开始election来选一个新leader。

- follower增加自己的current term然后变成candidate来开启election，他会给自己投票然后并行的给其他每个服务器发请求，直到三个事情中的一个发生 1 他在选举中胜出 2 其他服务器成为了leader 3 一段时间过去了没有获胜者

- candidate如果获得大部分在相同term的服务器的支持就可以获胜。每个服务器都只能给最多一个candidate投票，谁先发消息就投给谁。大部分服务器同意的设定确保了只有最多一个服务器可以成为leader。当candidate获胜了，他就要给其他人发heartbeat来确定authority同时防止新的election发生。（在safety中又给投票添加了一个条件。只有在一个服务器的log里面包含所有确认的entries的时候他才能被选为leader。这就意味着这个candidate的log 必须至少和别的服务器的log一样新，对于新的定义，如果两个log的term不一样那么term大的新，如果term一样那么长度长的新。）

- 在等待vote的时候candidate可能会收到Appendentries，说他是新的leader，如果这个leader的term大于等于current term，那么candidate就相信这个leader是真的，自己重新变回follower。否则就拒绝这个appendentries继续candidate状态

- 第三种情况是很多个服务器都成为了candidate，投票很分散没有人成为leader这种情况下会timeout然后增加current term重新开始新的一轮election，但是如果没有额外的办法的话，平票会一直发生。

- Raft采用了随机的election timeout，这样平票就很少而且会很快被解决。为了防止平票timeout一般在150ms-300ms之间，这样在大多数情况下就只会有一个server timeout，这种机制也解决了平票问题。

#### 实现细节

-  term并不会随着时间自加，一个人的term只会在要开始election的时候增加

- leader在sendheartbeat的时候可能会发现一个term更大的server

- 需要注意server的三种状态的转化，可以参考论文里面的图

### log replication 

- 当选出一个leader之后这个leader就开始给用户提供服务。每个用户请求都包含一个要被复制状态机（replicated state machine）执行的指令。leader把指令作为一个entry放进他的log里面然后并行地发AppendEntries RPC请求给其他的服务器来复制entry。当entry被安全的复制之后leader会用自己的state machine计算这个entry然后把结果返回给客户。在safety章节会讲到怎么样是安全的复制。如果follower挂了，或者跑得很慢或者网络包丢了，就算leader已经把结果返回给客户了，leader会持续不断的发AppendEntries ，直到所有客户都储存了所有的log entries。
- 每个log entries都储存了一个复制状态机的指令和leader收到entry时的term，term用来检测log之间的不一致并且保证了某些特质。每个log entry还有一个index来表示他在log中的位置。
- leader决定什么时候用自己的state machine计算entry是安全的，这种被计算过的entry被称为committed，raft保证了所有committed entries都是durable的并且会被所有的在工作的state machine执行。当leader创建了entry并且把他复制到大部分server上的时候entry就committed了。leader还会记录最大的committed的index然后把他放在之后的AppendEntries里面（包括heartbeat），这样其他的server就可以知道最大的committed index了。当follower知道一个entry是commited的时候他就按照log 的顺序用state machines计算entry。
- raft log 机制保持了不同服务器上log的高度协调，这样让系统的行为更加简单可预测，还可以借此保证安全性。如果两个entry有相同的index和term，那么在这个index之前的log都是相同的，raft用下面两个特性来保证这个机制 1）如果两个不同log里的entry有相同的term和index，那么他们储存相同的指令，2）如果两个在不同log里的entry有相同的index和term，log里他们之前的entry都是相同的。
- 第一个特性是因为在一个term里面leader最多只创建一个给定index的entry并且entry永远不会改变在log中的位置。第二个特性由一个简单的AppendEntries进行的共识检查保证。当发送AppendEntries RPC的时候leader会把新entry前的一个entry的term和index放在里面，如果follower没有在自己的log里面找到一个有相同index和term的entry，就拒绝新的entry。这个检查像一个归纳法：空的状态满足条件，这个检查在log扩展的时候让这个特性成立，所以每次AppendEntries返回成功的时候leader都知道follower的log在新entry之前都和自己的log一样。
- 在正常操作的时候，leader的log和follower的log是相同的，所以appendentries的consistence check永远是对的，但是 leader crash会导致log不一样，因为旧的leader可能还没有来得及复制他所有的log。这些不相同可能会在一系列leader和follower crash之中叠加。图七展示了follower和leader之间log可能不同的各种方式，一个follower可能会丢失现在leader有的entry，也可能有现在leader没有的entry，或者两种情况都发生。
- 在raft中，leader通过让follower复制自己的log来解决不一致。这意味着follower中有冲突的entry会被leader log 中的entry取代。5.4会论证加一个附加条件之后这样是安全的。
- 为了让follower的log和leader一致，leader必须找到一个最新的两者一致的log entry，然后删除follower log在那之后的所有entry并发送leader在那之后的所有entry给follower，所有的这些操作发生在appendentries rpc中进行的一致性检查的回复中。leader为每个follower维护一个nextIndex，代表了leader会发给他的下一个entry的index，当一个leader当选的时候，他把素有的nextIndex初始化为自己log 的最大index的后一个。如果follower的log和leader不一致，appendentry 一致性检查会在下一次rpc的时候失败。在rejection之后，leader会减少nextindex然后重试一致性检查。最终nextIndex会达到一个让leader和follower log一样的点。当这个情况发生的事哦呼，appendentries就成功了，他去除了follower所有冲突的entry并把leader 的entry放到了follower的log里面。一旦appendentries成功，follower的log和leader就一样了，并且会在这个term一直保持一样。
- 如果你想要的话，这个协议可以通过减少被拒绝的appendentries rpc的数量来优化。举个例子，当拒绝一个appendentries请求的时候，follower可以发送冲突entry的term和他为那个term储存的第一个index。用这个信息，leader可以减少nextIndex来跳过在那个term里面的所有冲突的entries。每个有冲突的term需要一个appendentries rpc而不是每个entry需要一次rpc。在现实情况下，这个优化可能是不需要的，因为失败不经常发生而且不太可能有很多不一致的entries。
- 用这个机制，leader不用在当选的时候采取特别的行动来恢复log一致性。他只要开始正常操作然后log就会自动为了应对appendentries的一致性检查保持一致。leader永远不会修改或者删除自己log里面的entries。
- 这种log复制机制展现了我们想要的共识特性：只要大部分server是可以用的，raft就可以接受，复制，操作新的log entries。在正常情况下一个新的entries会在一轮rpc中被复制到大部分server，单一的慢的follower不会影响表现。







